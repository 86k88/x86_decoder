#include "opcode_uop.h"

static int enc_eq(const x86_uop_encoding_t *a, const x86_uop_encoding_t *b) {
    if (a->pf != b->pf) return 0;
    if (a->op_len != b->op_len) return 0;
    if (a->modrm_ext != b->modrm_ext) return 0;
    for (int i=0;i<3;i++) if (a->op[i] != b->op[i]) return 0;
    return 1;
}
static int enc_eq_ignore_pf(const x86_uop_encoding_t *a, const x86_uop_encoding_t *b) {
    if (a->op_len != b->op_len) return 0;
    if (a->modrm_ext != b->modrm_ext) return 0;
    for (int i=0;i<3;i++) if (a->op[i] != b->op[i]) return 0;
    return 1;
}

static const uop_cc_t g_cc_by_nibble[16] = {
    UOP_CC_O,  UOP_CC_NO, UOP_CC_B,  UOP_CC_AE,
    UOP_CC_E,  UOP_CC_NE, UOP_CC_BE, UOP_CC_A,
    UOP_CC_S,  UOP_CC_NS, UOP_CC_P,  UOP_CC_NP,
    UOP_CC_L,  UOP_CC_GE, UOP_CC_LE, UOP_CC_G,
};

static const x86_uop_entry_t g_entries[] = {
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x00, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x01, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x02, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x03, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x04, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x05, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x06, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "ES", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x07, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POP",
        .op1 = "ES", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Pop a Value from the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x08, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x09, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x0A, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x0B, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x0C, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x0D, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x0E, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "CS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x0F, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "Two-byte Instructions",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x10, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x11, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x12, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x13, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x14, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x15, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x16, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "SS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x17, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POP",
        .op1 = "SS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Pop a Value from the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x18, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x19, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x1A, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x1B, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x1C, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x1D, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x1E, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "DS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x1F, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POP",
        .op1 = "DS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Pop a Value from the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x20, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x21, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x22, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x23, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x24, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x25, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x27, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_BCD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DAA",
        .op1 = "AL", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Decimal Adjust AL after Addition",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x28, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x29, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x2A, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x2B, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x2C, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x2D, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x2F, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_BCD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DAS",
        .op1 = "AL", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Decimal Adjust AL after Subtraction",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x30, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x31, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x32, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x33, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x34, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x35, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x37, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_BCD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "AAA",
        .op1 = "AL", .op2 = "AH", .op3 = "", .op4 = "",
        .iext = "", .notes = "ASCII Adjust After Addition",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x38, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x39, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x3A, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x3B, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x3C, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x3D, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x3F, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_BCD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "AAS",
        .op1 = "AL", .op2 = "AH", .op3 = "", .op4 = "",
        .iext = "", .notes = "ASCII Adjust AL After Subtraction",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x60, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSHA",
        .op1 = "AX", .op2 = "CX", .op3 = "DX", .op4 = "...",
        .iext = "", .notes = "Push All General-Purpose Registers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x61, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POPA",
        .op1 = "DI", .op2 = "SI", .op3 = "BP", .op4 = "...",
        .iext = "", .notes = "Pop All General-Purpose Registers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x62, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "BOUND",
        .op1 = "r16/32", .op2 = "m16/32&16/32", .op3 = "eFlags", .op4 = "",
        .iext = "", .notes = "Check Array Index Against Bounds",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x63, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ARPL",
        .op1 = "r/m16", .op2 = "r16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Adjust RPL Field of Segment Selector",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x68, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "imm16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x69, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_IMUL, .cc = UOP_CC_NONE,
        .mnemonic = "IMUL",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "imm16/32", .op4 = "",
        .iext = "", .notes = "Signed Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x6A, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "imm8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x6B, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_IMUL, .cc = UOP_CC_NONE,
        .mnemonic = "IMUL",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "imm8", .op4 = "",
        .iext = "", .notes = "Signed Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x6C, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INS",
        .op1 = "m8", .op2 = "DX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Input from Port to String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x6D, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INS",
        .op1 = "m16", .op2 = "DX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Input from Port to String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x6E, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "OUTS",
        .op1 = "DX", .op2 = "m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Output String to Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x6F, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "OUTS",
        .op1 = "DX", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Output String to Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x80, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x81, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x82, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADD, .cc = UOP_CC_NONE,
        .mnemonic = "ADD",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_OR, .cc = UOP_CC_NONE,
        .mnemonic = "OR",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Inclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_ADC, .cc = UOP_CC_NONE,
        .mnemonic = "ADC",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add with Carry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SBB, .cc = UOP_CC_NONE,
        .mnemonic = "SBB",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Integer Subtraction with Borrow",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_AND, .cc = UOP_CC_NONE,
        .mnemonic = "AND",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_SUB, .cc = UOP_CC_NONE,
        .mnemonic = "SUB",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_XOR, .cc = UOP_CC_NONE,
        .mnemonic = "XOR",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x83, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_CMP, .cc = UOP_CC_NONE,
        .mnemonic = "CMP",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Two Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x84, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x85, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x86, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_XCHG, .cc = UOP_CC_NONE,
        .mnemonic = "XCHG",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Exchange Register/Memory with Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x87, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_XCHG, .cc = UOP_CC_NONE,
        .mnemonic = "XCHG",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Exchange Register/Memory with Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x88, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x89, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x8A, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r8", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x8B, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x8C, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "m16", .op2 = "Sreg", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x8D, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_LEA, .cc = UOP_CC_NONE,
        .mnemonic = "LEA",
        .op1 = "r16/32", .op2 = "m", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Effective Address",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x8E, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "Sreg", .op2 = "r/m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x8F, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Pop a Value from the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x90, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_NOP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "NOP",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "No Operation",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 1, .op = {0x90, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_NOP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PAUSE",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Spin Loop Hint",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x98, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MOVX, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "CBW",
        .op1 = "AX", .op2 = "AL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Convert Byte to Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x99, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MOVX, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "CWD",
        .op1 = "DX", .op2 = "AX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Convert Word to Doubleword",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x9A, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_CALL, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CALLF",
        .op1 = "ptr16:16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Call Procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x9B, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FWAIT",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Check pending unmasked floating-point exceptions",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x9C, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSHF",
        .op1 = "Flags", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push FLAGS Register onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x9D, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POPF",
        .op1 = "Flags", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Pop Stack into FLAGS Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x9E, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SAHF",
        .op1 = "AH", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store AH into Flags",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0x9F, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LAHF",
        .op1 = "AH", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Status Flags into AH Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA0, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "AL", .op2 = "moffs8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA1, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "eAX", .op2 = "moffs16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA2, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "moffs8", .op2 = "AL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA3, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "moffs16/32", .op2 = "eAX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA4, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVS",
        .op1 = "m8", .op2 = "m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move Data from String to String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA5, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVS",
        .op1 = "m16", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move Data from String to String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA6, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CMPS",
        .op1 = "m8", .op2 = "m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare String Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA7, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CMPS",
        .op1 = "m16", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare String Operands",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA8, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xA9, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "eAX", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xAA, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "STOS",
        .op1 = "m8", .op2 = "AL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xAB, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "STOS",
        .op1 = "m16", .op2 = "AX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xAC, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LODS",
        .op1 = "AL", .op2 = "m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xAD, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LODS",
        .op1 = "AX", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xAE, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SCAS",
        .op1 = "m8", .op2 = "AL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Scan String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xAF, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SCAS",
        .op1 = "m16", .op2 = "AX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Scan String",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROL, .cc = UOP_CC_NONE,
        .mnemonic = "ROL",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROR, .cc = UOP_CC_NONE,
        .mnemonic = "ROR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCL, .cc = UOP_CC_NONE,
        .mnemonic = "RCL",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCR, .cc = UOP_CC_NONE,
        .mnemonic = "RCR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SHL",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHR, .cc = UOP_CC_NONE,
        .mnemonic = "SHR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SAL",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC0, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SAR, .cc = UOP_CC_NONE,
        .mnemonic = "SAR",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROL, .cc = UOP_CC_NONE,
        .mnemonic = "ROL",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROR, .cc = UOP_CC_NONE,
        .mnemonic = "ROR",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCL, .cc = UOP_CC_NONE,
        .mnemonic = "RCL",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCR, .cc = UOP_CC_NONE,
        .mnemonic = "RCR",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SHL",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHR, .cc = UOP_CC_NONE,
        .mnemonic = "SHR",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SAL",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC1, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SAR, .cc = UOP_CC_NONE,
        .mnemonic = "SAR",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC2, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RETN",
        .op1 = "imm16", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Return from procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC3, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RETN",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Return from procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC4, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LES",
        .op1 = "ES", .op2 = "r16/32", .op3 = "m16:16/32", .op4 = "",
        .iext = "", .notes = "Load Far Pointer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC5, 0x00, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LDS",
        .op1 = "DS", .op2 = "r16/32", .op3 = "m16:16/32", .op4 = "",
        .iext = "", .notes = "Load Far Pointer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC6, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC7, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC8, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ENTER",
        .op1 = "eBP", .op2 = "imm16", .op3 = "imm8", .op4 = "",
        .iext = "", .notes = "Make Stack Frame for Procedure Parameters",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xC9, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LEAVE",
        .op1 = "eBP", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "High Level Procedure Exit",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xCA, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_RET, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RETF",
        .op1 = "imm16", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Return from procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xCB, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_RET, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RETF",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Return from procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xCC, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INT",
        .op1 = "3", .op2 = "eFlags", .op3 = "", .op4 = "",
        .iext = "", .notes = "Call to Interrupt Procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xCD, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INT",
        .op1 = "imm8", .op2 = "eFlags", .op3 = "", .op4 = "",
        .iext = "", .notes = "Call to Interrupt Procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xCE, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INTO",
        .op1 = "eFlags", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Call to Interrupt Procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xCF, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_RET, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "IRET",
        .op1 = "Flags", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Interrupt Return",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROL, .cc = UOP_CC_NONE,
        .mnemonic = "ROL",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROR, .cc = UOP_CC_NONE,
        .mnemonic = "ROR",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCL, .cc = UOP_CC_NONE,
        .mnemonic = "RCL",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCR, .cc = UOP_CC_NONE,
        .mnemonic = "RCR",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SHL",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHR, .cc = UOP_CC_NONE,
        .mnemonic = "SHR",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SAL",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD0, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SAR, .cc = UOP_CC_NONE,
        .mnemonic = "SAR",
        .op1 = "r/m8", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROL, .cc = UOP_CC_NONE,
        .mnemonic = "ROL",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROR, .cc = UOP_CC_NONE,
        .mnemonic = "ROR",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCL, .cc = UOP_CC_NONE,
        .mnemonic = "RCL",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCR, .cc = UOP_CC_NONE,
        .mnemonic = "RCR",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SHL",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHR, .cc = UOP_CC_NONE,
        .mnemonic = "SHR",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SAL",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD1, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SAR, .cc = UOP_CC_NONE,
        .mnemonic = "SAR",
        .op1 = "r/m16/32", .op2 = "1", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROL, .cc = UOP_CC_NONE,
        .mnemonic = "ROL",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROR, .cc = UOP_CC_NONE,
        .mnemonic = "ROR",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCL, .cc = UOP_CC_NONE,
        .mnemonic = "RCL",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCR, .cc = UOP_CC_NONE,
        .mnemonic = "RCR",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SHL",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHR, .cc = UOP_CC_NONE,
        .mnemonic = "SHR",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SAL",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD2, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SAR, .cc = UOP_CC_NONE,
        .mnemonic = "SAR",
        .op1 = "r/m8", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROL, .cc = UOP_CC_NONE,
        .mnemonic = "ROL",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_ROR, .cc = UOP_CC_NONE,
        .mnemonic = "ROR",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCL, .cc = UOP_CC_NONE,
        .mnemonic = "RCL",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_RCR, .cc = UOP_CC_NONE,
        .mnemonic = "RCR",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Rotate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SHL",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHR, .cc = UOP_CC_NONE,
        .mnemonic = "SHR",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHL, .cc = UOP_CC_NONE,
        .mnemonic = "SAL",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD3, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SAR, .cc = UOP_CC_NONE,
        .mnemonic = "SAR",
        .op1 = "r/m16/32", .op2 = "CL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Shift",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD4, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_BCD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "AAM",
        .op1 = "AL", .op2 = "AH", .op3 = "", .op4 = "",
        .iext = "", .notes = "ASCII Adjust AX After Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD5, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_BCD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "AAD",
        .op1 = "AL", .op2 = "AH", .op3 = "", .op4 = "",
        .iext = "", .notes = "ASCII Adjust AX Before Division",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD6, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "undefined",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Undefined and Reserved; Does not Generate #UD",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD7, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "XLAT",
        .op1 = "AL", .op2 = "m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Table Look-up Translation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FADD",
        .op1 = "ST", .op2 = "m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FMUL",
        .op1 = "ST", .op2 = "m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FCOM",
        .op1 = "ST", .op2 = "STi/m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Real",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FCOMP",
        .op1 = "ST", .op2 = "STi/m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Real and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FSUB",
        .op1 = "ST", .op2 = "m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FSUBR",
        .op1 = "ST", .op2 = "m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FDIV",
        .op1 = "ST", .op2 = "m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD8, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FDIVR",
        .op1 = "ST", .op2 = "m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FLD",
        .op1 = "ST", .op2 = "STi/m32real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Floating Point Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FXCH",
        .op1 = "ST", .op2 = "STi", .op3 = "", .op4 = "",
        .iext = "", .notes = "Exchange Register Contents",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FST",
        .op1 = "m32real", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Floating Point Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FSTP",
        .op1 = "m32real", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Floating Point Value and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FLDENV",
        .op1 = "m14/28", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load x87 FPU Environment",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FLDCW",
        .op1 = "m16", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load x87 FPU Control Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FNSTENV",
        .op1 = "m14/28", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store x87 FPU Environment",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xD9, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FNSTCW",
        .op1 = "m16", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store x87 FPU Control Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIADD",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIMUL",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FICOM",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FICOMP",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Integer and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISUB",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISUBR",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIDIV",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDA, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIDIVR",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FILD",
        .op1 = "ST", .op2 = "m32int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISTTP",
        .op1 = "m32int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Store Integer with Truncation and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIST",
        .op1 = "m32int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISTP",
        .op1 = "m32int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Integer and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FNENI nop",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Treated as Integer NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FLD",
        .op1 = "ST", .op2 = "m80real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Floating Point Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FCOMI",
        .op1 = "ST", .op2 = "STi", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Floating Point Values and Set EFLAGS",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDB, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FSTP",
        .op1 = "m80real", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Floating Point Value and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FADD",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FMUL",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FCOM",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Real",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FCOMP",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Real and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FSUB",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FSUBR",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FDIV",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDC, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FDIVR",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FLD",
        .op1 = "ST", .op2 = "m64real", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Floating Point Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISTTP",
        .op1 = "m64int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Store Integer with Truncation and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FST",
        .op1 = "m64real", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Floating Point Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FSTP",
        .op1 = "m64real", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Floating Point Value and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FRSTOR",
        .op1 = "ST", .op2 = "ST1", .op3 = "ST2", .op4 = "...",
        .iext = "", .notes = "Restore x87 FPU State",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FUCOMP",
        .op1 = "ST", .op2 = "STi", .op3 = "", .op4 = "",
        .iext = "", .notes = "Unordered Compare Floating Point Values and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FNSAVE",
        .op1 = "m94/108", .op2 = "ST", .op3 = "ST1", .op4 = "...",
        .iext = "", .notes = "Store x87 FPU State",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDD, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FNSTSW",
        .op1 = "m16", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store x87 FPU Status Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIADD",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIMUL",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FICOM",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FICOMP",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Compare Integer and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISUB",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISUBR",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIDIV",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDE, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIDIVR",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Reverse Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FILD",
        .op1 = "ST", .op2 = "m16int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISTTP",
        .op1 = "m16int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Store Integer with Truncation and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FIST",
        .op1 = "m16int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISTP",
        .op1 = "m16int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Integer and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FBLD",
        .op1 = "ST", .op2 = "m80dec", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Binary Coded Decimal",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FILD",
        .op1 = "ST", .op2 = "m64int", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FBSTP",
        .op1 = "m80dec", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store BCD Integer and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xDF, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_FPU, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FISTP",
        .op1 = "m64int", .op2 = "ST", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Integer and Pop",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE0, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_LOOP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LOOPNZ",
        .op1 = "eCX", .op2 = "rel8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Decrement count; Jump short if count!=0 and ZF=0",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE1, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_LOOP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LOOPZ",
        .op1 = "eCX", .op2 = "rel8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Decrement count; Jump short if count!=0 and ZF=1",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE2, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_LOOP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LOOP",
        .op1 = "eCX", .op2 = "rel8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Decrement count; Jump short if count!=0",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE3, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_JCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_CX_Z,
        .mnemonic = "JCXZ",
        .op1 = "rel8", .op2 = "CX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Jump short if eCX register is 0",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE4, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "IN",
        .op1 = "AL", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Input from Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE5, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "IN",
        .op1 = "eAX", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Input from Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE6, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "OUT",
        .op1 = "imm8", .op2 = "AL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Output to Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE7, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "OUT",
        .op1 = "imm8", .op2 = "eAX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Output to Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE8, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_CALL, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CALL",
        .op1 = "rel16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Call Procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xE9, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_JMP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "JMP",
        .op1 = "rel16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Jump",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xEA, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_CTRL, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "JMPF",
        .op1 = "ptr16:16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Jump",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xEB, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_JMP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "JMP",
        .op1 = "rel8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Jump",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xEC, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "IN",
        .op1 = "AL", .op2 = "DX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Input from Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xED, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "IN",
        .op1 = "eAX", .op2 = "DX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Input from Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xEE, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "OUT",
        .op1 = "DX", .op2 = "AL", .op3 = "", .op4 = "",
        .iext = "", .notes = "Output to Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xEF, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_PORTIO, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "OUT",
        .op1 = "DX", .op2 = "eAX", .op3 = "", .op4 = "",
        .iext = "", .notes = "Output to Port",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF1, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "undefined",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Undefined and Reserved; Does not Generate #UD",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF4, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_HLT, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HLT",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Halt",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF5, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CMC",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Complement Carry Flag",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "r/m8", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_NOT, .cc = UOP_CC_NONE,
        .mnemonic = "NOT",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "One's Complement Negation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_NEG, .cc = UOP_CC_NONE,
        .mnemonic = "NEG",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Two's Complement Negation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_MUL, .cc = UOP_CC_NONE,
        .mnemonic = "MUL",
        .op1 = "AX", .op2 = "AL", .op3 = "r/m8", .op4 = "",
        .iext = "", .notes = "Unsigned Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_IMUL, .cc = UOP_CC_NONE,
        .mnemonic = "IMUL",
        .op1 = "AX", .op2 = "AL", .op3 = "r/m8", .op4 = "",
        .iext = "", .notes = "Signed Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_DIV, .cc = UOP_CC_NONE,
        .mnemonic = "DIV",
        .op1 = "AL", .op2 = "AH", .op3 = "AX", .op4 = "r/m8",
        .iext = "", .notes = "Unsigned Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF6, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_IDIV, .cc = UOP_CC_NONE,
        .mnemonic = "IDIV",
        .op1 = "AL", .op2 = "AH", .op3 = "AX", .op4 = "r/m8",
        .iext = "", .notes = "Signed Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_TEST, .cc = UOP_CC_NONE,
        .mnemonic = "TEST",
        .op1 = "r/m16/32", .op2 = "imm16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_NOT, .cc = UOP_CC_NONE,
        .mnemonic = "NOT",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "One's Complement Negation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_NEG, .cc = UOP_CC_NONE,
        .mnemonic = "NEG",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Two's Complement Negation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_MUL, .cc = UOP_CC_NONE,
        .mnemonic = "MUL",
        .op1 = "eDX", .op2 = "eAX", .op3 = "r/m16/32", .op4 = "",
        .iext = "", .notes = "Unsigned Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_IMUL, .cc = UOP_CC_NONE,
        .mnemonic = "IMUL",
        .op1 = "eDX", .op2 = "eAX", .op3 = "r/m16/32", .op4 = "",
        .iext = "", .notes = "Signed Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_DIV, .cc = UOP_CC_NONE,
        .mnemonic = "DIV",
        .op1 = "eDX", .op2 = "eAX", .op3 = "r/m16/32", .op4 = "",
        .iext = "", .notes = "Unsigned Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF7, 0x00, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_IDIV, .cc = UOP_CC_NONE,
        .mnemonic = "IDIV",
        .op1 = "eDX", .op2 = "eAX", .op3 = "r/m16/32", .op4 = "",
        .iext = "", .notes = "Signed Divide",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF8, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CLC",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Clear Carry Flag",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xF9, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "STC",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Carry Flag",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFA, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CLI",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Clear Interrupt Flag",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFB, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "STI",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Interrupt Flag",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFC, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CLD",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Clear Direction Flag",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFD, 0x00, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_FLAGS, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "STD",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Direction Flag",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFE, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_INC, .cc = UOP_CC_NONE,
        .mnemonic = "INC",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Increment by 1",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFE, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_DEC, .cc = UOP_CC_NONE,
        .mnemonic = "DEC",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Decrement by 1",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFF, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_INC, .cc = UOP_CC_NONE,
        .mnemonic = "INC",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Increment by 1",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFF, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_ALU, .alu_op = UOP_ALU_DEC, .cc = UOP_CC_NONE,
        .mnemonic = "DEC",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Decrement by 1",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFF, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_CALL, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CALL",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Call Procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFF, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_CALL, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CALLF",
        .op1 = "m16:16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Call Procedure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFF, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_JMP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "JMP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Jump",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFF, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "JMPF",
        .op1 = "m16:16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Jump",
    },
    {
        .enc = { .pf = 0x00, .op_len = 1, .op = {0xFF, 0x00, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x00, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SLDT",
        .op1 = "m16", .op2 = "LDTR", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Local Descriptor Table Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x00, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "STR",
        .op1 = "m16", .op2 = "TR", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Task Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x00, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LLDT",
        .op1 = "LDTR", .op2 = "r/m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Local Descriptor Table Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x00, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LTR",
        .op1 = "TR", .op2 = "r/m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Task Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x00, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VERR",
        .op1 = "r/m16", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Verify a Segment for Reading",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x00, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VERW",
        .op1 = "r/m16", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Verify a Segment for Writing",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x01, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SGDT",
        .op1 = "m", .op2 = "GDTR", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Global Descriptor Table Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x01, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SIDT",
        .op1 = "m", .op2 = "IDTR", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Interrupt Descriptor Table Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x01, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LGDT",
        .op1 = "GDTR", .op2 = "m", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Global Descriptor Table Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x01, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LIDT",
        .op1 = "IDTR", .op2 = "m", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Interrupt Descriptor Table Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x01, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SMSW",
        .op1 = "m16", .op2 = "MSW", .op3 = "", .op4 = "",
        .iext = "", .notes = "Store Machine Status Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x01, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LMSW",
        .op1 = "MSW", .op2 = "r/m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Machine Status Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x01, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INVLPG",
        .op1 = "m", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Invalidate TLB Entry",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x02, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LAR",
        .op1 = "r16/32", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Access Rights Byte",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x03, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LSL",
        .op1 = "r16/32", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Load Segment Limit",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x06, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CLTS",
        .op1 = "CR0", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Clear Task-Switched Flag in CR0",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x08, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INVD",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Invalidate Internal Caches",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x09, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "WBINVD",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Write Back and Invalidate Cache",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x0B, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UD2",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Undefined Instruction",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x0D, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_NOP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "No Operation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x10, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVUPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Unaligned Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x10, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVUPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Unaligned Packed Double-FP Value",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x10, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Scalar Double-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x10, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x11, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVUPS",
        .op1 = "xmm/m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Unaligned Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x11, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVUPD",
        .op1 = "xmm/m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Unaligned Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x11, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSD",
        .op1 = "xmm/m64", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Scalar Double-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x11, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSS",
        .op1 = "xmm/m32", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x12, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVHLPS",
        .op1 = "xmm", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Packed Single-FP Values High to Low",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x12, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVLPD",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Low Packed Double-FP Value",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x12, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVDDUP",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Move One Double-FP and Duplicate",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x12, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSLDUP",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Move Packed Single-FP Low and Duplicate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x13, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVLPS",
        .op1 = "m64", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Low Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x13, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVLPD",
        .op1 = "m64", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Low Packed Double-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x14, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UNPCKLPS",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Unpack and Interleave Low Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x14, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UNPCKLPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack and Interleave Low Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x15, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UNPCKHPS",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Unpack and Interleave High Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x15, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UNPCKHPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack and Interleave High Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x16, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVLHPS",
        .op1 = "xmm", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Packed Single-FP Values Low to High",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x16, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVHPD",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move High Packed Double-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x16, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSHDUP",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Move Packed Single-FP High and Duplicate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x17, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVHPS",
        .op1 = "m64", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move High Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x17, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVHPD",
        .op1 = "m64", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move High Packed Double-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PREFETCHNTA",
        .op1 = "m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Prefetch Data Into Caches",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PREFETCHT0",
        .op1 = "m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Prefetch Data Into Caches",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PREFETCHT1",
        .op1 = "m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Prefetch Data Into Caches",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PREFETCHT2",
        .op1 = "m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Prefetch Data Into Caches",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x18, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x19, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1A, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1B, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1C, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1D, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1E, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_NOP, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "No Operation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x1F, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HINT_NOP",
        .op1 = "r/m16/32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Hintable NOP",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x20, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r32", .op2 = "CRn", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move to/from Control Registers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x21, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "r32", .op2 = "DRn", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move to/from Debug Registers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x22, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "CRn", .op2 = "r32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move to/from Control Registers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x23, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOV, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOV",
        .op1 = "DRn", .op2 = "r32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move to/from Debug Registers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x28, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVAPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Aligned Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x28, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVAPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Aligned Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x29, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVAPS",
        .op1 = "xmm/m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Aligned Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x29, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVAPD",
        .op1 = "xmm/m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Aligned Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x2A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPI2PS",
        .op1 = "xmm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Convert Packed DW Integers to Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x2A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPI2PD",
        .op1 = "xmm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed DW Integers to Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x2A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTSI2SD",
        .op1 = "xmm", .op2 = "r/m32", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert DW Integer to Scalar Double-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x2A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTSI2SS",
        .op1 = "xmm", .op2 = "r/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Convert DW Integer to Scalar Single-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x2B, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVNTPS",
        .op1 = "m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Store Packed Single-FP Values Using Non-Temporal Hint",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x2B, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVNTPD",
        .op1 = "m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Store Packed Double-FP Values Using Non-Temporal Hint",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x2C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTTPS2PI",
        .op1 = "mm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Convert with Trunc. Packed Single-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x2C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTTPD2PI",
        .op1 = "mm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert with Trunc. Packed Double-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x2C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTTSD2SI",
        .op1 = "r32", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Conv. with Trunc. Scalar Double-FP Value to Signed DW Int",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x2C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTTSS2SI",
        .op1 = "r32", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Convert with Trunc. Scalar Single-FP Value to DW Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x2D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPS2PI",
        .op1 = "mm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Convert Packed Single-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x2D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPD2PI",
        .op1 = "mm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed Double-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x2D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTSD2SI",
        .op1 = "r32", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Scalar Double-FP Value to DW Integer",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x2D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTSS2SI",
        .op1 = "r32", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Convert Scalar Single-FP Value to DW Integer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x2E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UCOMISS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Unordered Compare Scalar Single-FP Values and Set EFLAGS",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x2E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UCOMISD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unordered Compare Scalar Double-FP Values and Set EFLAGS",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x2F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "COMISS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compare Scalar Ordered Single-FP Values and Set EFLAGS",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x2F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "COMISD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compare Scalar Ordered Double-FP Values and Set EFLAGS",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x30, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "WRMSR",
        .op1 = "MSR", .op2 = "ECX", .op3 = "EAX", .op4 = "EDX",
        .iext = "", .notes = "Write to Model Specific Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x31, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RDTSC",
        .op1 = "EAX", .op2 = "EDX", .op3 = "IA32_TIM", .op4 = "",
        .iext = "", .notes = "Read Time-Stamp Counter",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x32, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RDMSR",
        .op1 = "EAX", .op2 = "EDX", .op3 = "ECX", .op4 = "MSR",
        .iext = "", .notes = "Read from Model Specific Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x33, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RDPMC",
        .op1 = "EAX", .op2 = "EDX", .op3 = "PMC", .op4 = "",
        .iext = "", .notes = "Read Performance-Monitoring Counters",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x34, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SYSENTER",
        .op1 = "SS", .op2 = "ESP", .op3 = "IA32_SYS", .op4 = "...",
        .iext = "", .notes = "Fast System Call",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x35, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SYSEXIT",
        .op1 = "SS", .op2 = "eSP", .op3 = "IA32_SYS", .op4 = "...",
        .iext = "", .notes = "Fast Return from Fast System Call",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x37, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "GETSEC",
        .op1 = "EAX", .op2 = "", .op3 = "", .op4 = "",
        .iext = "smx", .notes = "GETSEC Leaf Functions",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x50, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVMSKPS",
        .op1 = "r32", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Extract Packed Single-FP Sign Mask",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x50, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVMSKPD",
        .op1 = "r32", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Extract Packed Double-FP Sign Mask",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x51, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SQRTPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Square Roots of Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x51, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SQRTPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compute Square Roots of Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x51, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SQRTSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compute Square Root of Scalar Double-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x51, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SQRTSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Square Root of Scalar Single-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x52, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RSQRTPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Recipr. of Square Roots of Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x52, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RSQRTSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Recipr. of Square Root of Scalar Single-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x53, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RCPPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Reciprocals of Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x53, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RCPSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Reciprocal of Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x54, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ANDPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Bitwise Logical AND of Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x54, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ANDPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Bitwise Logical AND of Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x55, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ANDNPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Bitwise Logical AND NOT of Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x55, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ANDNPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Bitwise Logical AND NOT of Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x56, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ORPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Bitwise Logical OR of Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x56, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ORPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Bitwise Logical OR of Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x57, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "XORPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Bitwise Logical XOR for Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x57, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "XORPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Bitwise Logical XOR for Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x58, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ADDPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Add Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x58, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ADDPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x58, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ADDSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Scalar Double-FP Values",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x58, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ADDSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Add Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x59, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MULPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Multiply Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x59, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MULPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Multiply Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x59, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MULSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Multiply Scalar Double-FP Values",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x59, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MULSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Multiply Scalar Single-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x5A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPS2PD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed Single-FP Values to Double-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x5A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPD2PS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed Double-FP Values to Single-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x5A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTSD2SS",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Scalar Double-FP Value to Scalar Single-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x5A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTSS2SD",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Scalar Single-FP Value to Scalar Double-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x5B, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTDQ2PS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed DW Integers to Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x5B, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPS2DQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed Single-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x5B, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTTPS2DQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert with Trunc. Packed Single-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x5C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SUBPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Subtract Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x5C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SUBPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x5C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SUBSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Scalar Double-FP Values",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x5C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SUBSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Subtract Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x5D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MINPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Return Minimum Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x5D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MINPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Return Minimum Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x5D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MINSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Return Minimum Scalar Double-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x5D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MINSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Return Minimum Scalar Single-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x5E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DIVPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Divide Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x5E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DIVPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Divide Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x5E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DIVSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Divide Scalar Double-FP Values",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x5E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DIVSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Divide Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x5F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MAXPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Return Maximum Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x5F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MAXPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Return Maximum Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x5F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MAXSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Return Maximum Scalar Double-FP Value",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x5F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MAXSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Return Maximum Scalar Single-FP Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x60, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKLBW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Unpack Low Data",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x60, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKLBW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack Low Data",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x61, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKLWD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Unpack Low Data",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x61, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKLWD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack Low Data",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x62, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKLDQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Unpack Low Data",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x62, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKLDQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack Low Data",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x63, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PACKSSWB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Pack with Signed Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x63, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PACKSSWB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Pack with Signed Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x64, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPGTB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Compare Packed Signed Integers for Greater Than",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x64, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPGTB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compare Packed Signed Integers for Greater Than",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x65, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPGTW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Compare Packed Signed Integers for Greater Than",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x65, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPGTW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compare Packed Signed Integers for Greater Than",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x66, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPGTD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Compare Packed Signed Integers for Greater Than",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x66, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPGTD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compare Packed Signed Integers for Greater Than",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x67, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PACKUSWB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Pack with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x67, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PACKUSWB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Pack with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x68, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKHBW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Unpack High Data",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x68, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKHBW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack High Data",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x69, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKHWD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Unpack High Data",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x69, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKHWD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack High Data",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x6A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKHDQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Unpack High Data",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x6A, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKHDQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack High Data",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x6B, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PACKSSDW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Pack with Signed Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x6B, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PACKSSDW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Pack with Signed Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x6C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKLQDQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack Low Data",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x6D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUNPCKHQDQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Unpack High Data",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x6E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVD",
        .op1 = "mm", .op2 = "r/m32", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Move Doubleword",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x6E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVD",
        .op1 = "xmm", .op2 = "r/m32", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Doubleword",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x6F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Move Quadword",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x6F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVDQA",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Aligned Double Quadword",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x6F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVDQU",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Unaligned Double Quadword",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x70, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSHUFW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Shuffle Packed Words",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x70, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSHUFD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse2", .notes = "Shuffle Packed Doublewords",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x70, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSHUFLW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse2", .notes = "Shuffle Packed Low Words",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x70, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSHUFHW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse2", .notes = "Shuffle Packed High Words",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x71, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLW",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x71, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAW",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x71, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLW",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x71, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLW",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x71, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAW",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x71, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLW",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x72, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLD",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Double Quadword Right Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x72, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAD",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x72, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLD",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x72, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLD",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Double Quadword Right Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x72, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAD",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x72, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLD",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x73, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLQ",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x73, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLQ",
        .op1 = "mm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x73, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLQ",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x73, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLDQ",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Double Quadword Right Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x73, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLQ",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x73, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLDQ",
        .op1 = "xmm", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Double Quadword Left Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x74, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPEQB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Compare Packed Data for Equal",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x74, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPEQB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compare Packed Data for Equal",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x75, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPEQW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Compare Packed Data for Equal",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x75, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPEQW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compare Packed Data for Equal",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x76, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPEQD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Compare Packed Data for Equal",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x76, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPEQD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Compare Packed Data for Equal",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x77, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "EMMS",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Empty MMX Technology State",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x78, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMREAD",
        .op1 = "r/m32", .op2 = "r32", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Read Field from Virtual-Machine Control Structure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x79, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMWRITE",
        .op1 = "r32", .op2 = "r/m32", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Write Field to Virtual-Machine Control Structure",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x7C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HADDPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Packed Double-FP Horizontal Add",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x7C, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HADDPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Packed Single-FP Horizontal Add",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x7D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HSUBPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Packed Double-FP Horizontal Subtract",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0x7D, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "HSUBPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Packed Single-FP Horizontal Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x7E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVD",
        .op1 = "r/m32", .op2 = "mm", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Move Doubleword",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x7E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVD",
        .op1 = "r/m32", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Doubleword",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x7E, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVQ",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Quadword",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x7F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVQ",
        .op1 = "mm/m64", .op2 = "mm", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Move Quadword",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0x7F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVDQA",
        .op1 = "xmm/m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Aligned Double Quadword",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0x7F, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVDQU",
        .op1 = "xmm/m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Unaligned Double Quadword",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x90, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_O,
        .mnemonic = "SETO",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - overflow (OF=1)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x91, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NO,
        .mnemonic = "SETNO",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not overflow (OF=0)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x92, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_B,
        .mnemonic = "SETB",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - below/not above or equal/carry (CF=1)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x93, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_AE,
        .mnemonic = "SETNB",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not below/above or equal/not carry (CF=0)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x94, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_E,
        .mnemonic = "SETZ",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - zero/equal (ZF=1)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x95, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NE,
        .mnemonic = "SETNZ",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not zero/not equal (ZF=0)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x96, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_BE,
        .mnemonic = "SETBE",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - below or equal/not above (CF=1 OR ZF=1)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x97, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_A,
        .mnemonic = "SETNBE",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not below or equal/above (CF=0 AND ZF=0)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x98, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_S,
        .mnemonic = "SETS",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - sign (SF=1)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x99, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NS,
        .mnemonic = "SETNS",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not sign (SF=0)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x9A, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_P,
        .mnemonic = "SETP",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - parity/parity even (PF=1)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x9B, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NP,
        .mnemonic = "SETNP",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not parity/parity odd (PF=0)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x9C, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_L,
        .mnemonic = "SETL",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - less/not greater (SF!=OF)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x9D, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_GE,
        .mnemonic = "SETNL",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not less/greater or equal (SF=OF)",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x9E, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_LE,
        .mnemonic = "SETLE",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - less or equal/not greater ((ZF=1) OR (SF!=OF))",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0x9F, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SETCC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_G,
        .mnemonic = "SETNLE",
        .op1 = "r/m8", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Set Byte on Condition - not less nor equal/greater ((ZF=0) AND (SF=OF))",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA0, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "FS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA1, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POP",
        .op1 = "FS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Pop a Value from the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA2, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CPUID",
        .op1 = "IA32_BIOS_", .op2 = "EAX", .op3 = "ECX", .op4 = "...",
        .iext = "", .notes = "CPU Identification",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BT, .cc = UOP_CC_NONE,
        .mnemonic = "BT",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHLD, .cc = UOP_CC_NONE,
        .mnemonic = "SHLD",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "imm8", .op4 = "",
        .iext = "", .notes = "Double Precision Shift Left",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHLD, .cc = UOP_CC_NONE,
        .mnemonic = "SHLD",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "CL", .op4 = "",
        .iext = "", .notes = "Double Precision Shift Left",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA8, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PUSH",
        .op1 = "GS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Push Word, Doubleword or Quadword Onto the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xA9, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_STACK, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POP",
        .op1 = "GS", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Pop a Value from the Stack",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAA, 0x00}, .modrm_ext = -1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RSM",
        .op1 = "Flags", .op2 = "", .op3 = "", .op4 = "",
        .iext = "", .notes = "Resume from System Management Mode",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BTS, .cc = UOP_CC_NONE,
        .mnemonic = "BTS",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test and Set",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHRD, .cc = UOP_CC_NONE,
        .mnemonic = "SHRD",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "imm8", .op4 = "",
        .iext = "", .notes = "Double Precision Shift Right",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAD, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SHIFT, .alu_op = UOP_ALU_SHRD, .cc = UOP_CC_NONE,
        .mnemonic = "SHRD",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "CL", .op4 = "",
        .iext = "", .notes = "Double Precision Shift Right",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 0 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FXSAVE",
        .op1 = "m512", .op2 = "ST", .op3 = "ST1", .op4 = "...",
        .iext = "", .notes = "Save x87 FPU, MMX, XMM, and MXCSR State",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "FXRSTOR",
        .op1 = "ST", .op2 = "ST1", .op3 = "ST2", .op4 = "...",
        .iext = "", .notes = "Restore x87 FPU, MMX, XMM, and MXCSR State",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LDMXCSR",
        .op1 = "m32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Load MXCSR Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 3 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "STMXCSR",
        .op1 = "m32", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Store MXCSR Register State",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "XSAVE",
        .op1 = "m", .op2 = "EDX", .op3 = "EAX", .op4 = "...",
        .iext = "", .notes = "Save Processor Extended States",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LFENCE",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Load Fence",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MFENCE",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Memory Fence",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAE, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SFENCE",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Store Fence",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xAF, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MULDIV, .alu_op = UOP_ALU_IMUL, .cc = UOP_CC_NONE,
        .mnemonic = "IMUL",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Signed Multiply",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB0, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_CMPXCHG, .alu_op = UOP_ALU_CMPXCHG, .cc = UOP_CC_NONE,
        .mnemonic = "CMPXCHG",
        .op1 = "r/m8", .op2 = "AL", .op3 = "r8", .op4 = "",
        .iext = "", .notes = "Compare and Exchange",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_CMPXCHG, .alu_op = UOP_ALU_CMPXCHG, .cc = UOP_CC_NONE,
        .mnemonic = "CMPXCHG",
        .op1 = "r/m16/32", .op2 = "eAX", .op3 = "r16/32", .op4 = "",
        .iext = "", .notes = "Compare and Exchange",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LSS",
        .op1 = "SS", .op2 = "r16/32", .op3 = "m16:16/32", .op4 = "",
        .iext = "", .notes = "Load Far Pointer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BTR, .cc = UOP_CC_NONE,
        .mnemonic = "BTR",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test and Reset",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LFS",
        .op1 = "FS", .op2 = "r16/32", .op3 = "m16:16/32", .op4 = "",
        .iext = "", .notes = "Load Far Pointer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LGS",
        .op1 = "GS", .op2 = "r16/32", .op3 = "m16:16/32", .op4 = "",
        .iext = "", .notes = "Load Far Pointer",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOVX, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOVZX",
        .op1 = "r16/32", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move with Zero-Extend",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB7, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MOVX, .alu_op = UOP_ALU_MOV, .cc = UOP_CC_NONE,
        .mnemonic = "MOVZX",
        .op1 = "r16/32", .op2 = "r/m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move with Zero-Extend",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0xB8, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POPCNT",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Population Count",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xB9, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "UD",
        .op1 = "r", .op2 = "r/m", .op3 = "", .op4 = "",
        .iext = "", .notes = "Undefined Instruction",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBA, 0x00}, .modrm_ext = 4 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BT, .cc = UOP_CC_NONE,
        .mnemonic = "BT",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBA, 0x00}, .modrm_ext = 5 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BTS, .cc = UOP_CC_NONE,
        .mnemonic = "BTS",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test and Set",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBA, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BTR, .cc = UOP_CC_NONE,
        .mnemonic = "BTR",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test and Reset",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBA, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BTC, .cc = UOP_CC_NONE,
        .mnemonic = "BTC",
        .op1 = "r/m16/32", .op2 = "imm8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test and Complement",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BTC, .cc = UOP_CC_NONE,
        .mnemonic = "BTC",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Test and Complement",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BSF, .cc = UOP_CC_NONE,
        .mnemonic = "BSF",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Scan Forward",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBD, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_BIT, .alu_op = UOP_ALU_BSR, .cc = UOP_CC_NONE,
        .mnemonic = "BSR",
        .op1 = "r16/32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Bit Scan Reverse",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBE, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSX",
        .op1 = "r16/32", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move with Sign-Extension",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xBF, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVSX",
        .op1 = "r16/32", .op2 = "r/m16", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move with Sign-Extension",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC0, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_XADD, .alu_op = UOP_ALU_XADD, .cc = UOP_CC_NONE,
        .mnemonic = "XADD",
        .op1 = "r/m8", .op2 = "r8", .op3 = "", .op4 = "",
        .iext = "", .notes = "Exchange and Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_XADD, .alu_op = UOP_ALU_XADD, .cc = UOP_CC_NONE,
        .mnemonic = "XADD",
        .op1 = "r/m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Exchange and Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CMPPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Compare Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xC2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CMPPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse2", .notes = "Compare Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0xC2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CMPSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "imm8", .op4 = "",
        .iext = "sse2", .notes = "Compare Scalar Double-FP Values",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0xC2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CMPSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Compare Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVNTI",
        .op1 = "m32", .op2 = "r32", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Store Doubleword Using Non-Temporal Hint",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PINSRW",
        .op1 = "mm", .op2 = "r32", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Insert Word",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xC4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PINSRW",
        .op1 = "xmm", .op2 = "r32", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Insert Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PEXTRW",
        .op1 = "r32", .op2 = "mm", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Extract Word",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xC5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PEXTRW",
        .op1 = "r32", .op2 = "xmm", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Extract Word",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SHUFPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse1", .notes = "Shuffle Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xC6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "SHUFPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse2", .notes = "Shuffle Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC7, 0x00}, .modrm_ext = 1 },
        .recipe = UOP_REC_CMPXCHG, .alu_op = UOP_ALU_CMPXCHG, .cc = UOP_CC_NONE,
        .mnemonic = "CMPXCHG8B",
        .op1 = "m64", .op2 = "EAX", .op3 = "EDX", .op4 = "...",
        .iext = "", .notes = "Compare and Exchange Bytes",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC7, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMPTRLD",
        .op1 = "m64", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Load Pointer to Virtual-Machine Control Structure",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xC7, 0x00}, .modrm_ext = 7 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMPTRST",
        .op1 = "m64", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Store Pointer to Virtual-Machine Control Structure",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xC7, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMCLEAR",
        .op1 = "m64", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Clear Virtual-Machine Control Structure",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0xC7, 0x00}, .modrm_ext = 6 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMXON",
        .op1 = "m64", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Enter VMX Operation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD0, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ADDSUBPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Packed Double-FP Add/Subtract",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0xD0, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ADDSUBPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Packed Single-FP Add/Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRLQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Quadword Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Quadword Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULLW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Multiply Packed Signed Integers and Store Low Result",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULLW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Multiply Packed Signed Integers and Store Low Result",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVQ",
        .op1 = "xmm/m64", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Quadword",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0xD6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVDQ2Q",
        .op1 = "mm", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Quadword from XMM to MMX Technology Register",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0xD6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVQ2DQ",
        .op1 = "xmm", .op2 = "mm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Move Quadword from MMX Technology to XMM Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD7, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVMSKB",
        .op1 = "r32", .op2 = "mm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Byte Mask",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD7, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVMSKB",
        .op1 = "r32", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Move Byte Mask",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD8, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBUSB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Subtract Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD8, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBUSB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xD9, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBUSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Subtract Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xD9, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBUSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xDA, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINUB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Minimum of Packed Unsigned Byte Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xDA, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINUB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Minimum of Packed Unsigned Byte Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xDB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PAND",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xDB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PAND",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Logical AND",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xDC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDUSB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Add Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xDC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDUSB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xDD, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDUSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Add Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xDD, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDUSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Unsigned Integers with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xDE, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXUB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Maximum of Packed Unsigned Byte Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xDE, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXUB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Maximum of Packed Unsigned Byte Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xDF, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PANDN",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Logical AND NOT",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xDF, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PANDN",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Logical AND NOT",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE0, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PAVGB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Average Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE0, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PAVGB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Average Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSRAD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Right Arithmetic",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PAVGW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Average Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PAVGW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Average Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULHUW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Multiply Packed Unsigned Integers and Store High Result",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULHUW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Multiply Packed Unsigned Integers and Store High Result",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULHW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Multiply Packed Signed Integers and Store High Result",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULHW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Multiply Packed Signed Integers and Store High Result",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTTPD2DQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert with Trunc. Packed Double-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0xE6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTPD2DQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed Double-FP Values to DW Integers",
    },
    {
        .enc = { .pf = 0xF3, .op_len = 2, .op = {0x0F, 0xE6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CVTDQ2PD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Convert Packed DW Integers to Double-FP Values",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE7, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVNTQ",
        .op1 = "m64", .op2 = "mm", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Store of Quadword Using Non-Temporal Hint",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE7, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVNTDQ",
        .op1 = "m128", .op2 = "xmm", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Store Double Quadword Using Non-Temporal Hint",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE8, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBSB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Subtract Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE8, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBSB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xE9, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Subtract Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xE9, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xEA, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Minimum of Packed Signed Word Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xEA, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Minimum of Packed Signed Word Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xEB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POR",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Bitwise Logical OR",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xEB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "POR",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Bitwise Logical OR",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xEC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDSB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Add Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xEC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDSB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xED, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Add Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xED, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Signed Integers with Signed Saturation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xEE, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Maximum of Packed Signed Word Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xEE, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Maximum of Packed Signed Word Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xEF, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PXOR",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xEF, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PXOR",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Logical Exclusive OR",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 2, .op = {0x0F, 0xF0, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "LDDQU",
        .op1 = "xmm", .op2 = "m128", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Load Unaligned Integer 128 Bits",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF1, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF2, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF3, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSLLQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Shift Packed Data Left Logical",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULUDQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Multiply Packed Unsigned DW Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF4, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULUDQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Multiply Packed Unsigned DW Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMADDWD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Multiply and Add Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF5, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMADDWD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Multiply and Add Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSADBW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Sum of Absolute Differences",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF6, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSADBW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse1", .notes = "Compute Sum of Absolute Differences",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF7, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MASKMOVQ",
        .op1 = "m64", .op2 = "mm", .op3 = "mm", .op4 = "",
        .iext = "sse1", .notes = "Store Selected Bytes of Quadword",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF7, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MASKMOVDQU",
        .op1 = "m128", .op2 = "xmm", .op3 = "xmm", .op4 = "",
        .iext = "sse2", .notes = "Store Selected Bytes of Double Quadword",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF8, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Subtract Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF8, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xF9, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Subtract Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xF9, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xFA, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Subtract Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xFA, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xFB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBQ",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Quadword Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xFB, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSUBQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Subtract Packed Quadword Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xFC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Add Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xFC, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xFD, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Add Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xFD, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 2, .op = {0x0F, 0xFE, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "mmx", .notes = "Add Packed Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 2, .op = {0x0F, 0xFE, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PADDD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse2", .notes = "Add Packed Integers",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xC1}, .modrm_ext = 0 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMCALL",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Call to VM Monitor",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xC2}, .modrm_ext = 0 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMLAUNCH",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Launch Virtual Machine",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xC3}, .modrm_ext = 0 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMRESUME",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Resume Virtual Machine",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xC4}, .modrm_ext = 0 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "VMXOFF",
        .op1 = "", .op2 = "", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Leave VMX Operation",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xC8}, .modrm_ext = 1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MONITOR",
        .op1 = "m8", .op2 = "ECX", .op3 = "EDX", .op4 = "",
        .iext = "sse3", .notes = "Set Up Monitor Address",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xC9}, .modrm_ext = 1 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MWAIT",
        .op1 = "EAX", .op2 = "ECX", .op3 = "", .op4 = "",
        .iext = "sse3", .notes = "Monitor Wait",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xD0}, .modrm_ext = 2 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "XGETBV",
        .op1 = "EDX", .op2 = "EAX", .op3 = "ECX", .op4 = "XCR",
        .iext = "", .notes = "Get Value of Extended Control Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xD1}, .modrm_ext = 2 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "XSETBV",
        .op1 = "XCR", .op2 = "ECX", .op3 = "EDX", .op4 = "EAX",
        .iext = "", .notes = "Set Extended Control Register",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x01, 0xF9}, .modrm_ext = 7 },
        .recipe = UOP_REC_SYSTEM, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "RDTSCP",
        .op1 = "EAX", .op2 = "EDX", .op3 = "ECX", .op4 = "...",
        .iext = "", .notes = "Read Time-Stamp Counter and Processor ID",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSHUFB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Shuffle Bytes",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x00}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSHUFB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Shuffle Bytes",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x01}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHADDW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Add",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x01}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHADDW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x02}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHADDD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Add",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x02}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHADDD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Add",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x03}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHADDSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Add and Saturate",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x03}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHADDSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Add and Saturate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x04}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMADDUBSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Multiply and Add Packed Signed and Unsigned Bytes",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x04}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMADDUBSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Multiply and Add Packed Signed and Unsigned Bytes",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x05}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHSUBW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Subtract",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x05}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHSUBW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x06}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHSUBD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Subtract",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x06}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHSUBD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Subtract",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x07}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHSUBSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Subtract and Saturate",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x07}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHSUBSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Horizontal Subtract and Saturate",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x08}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSIGNB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed SIGN",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x08}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSIGNB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed SIGN",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x09}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSIGNW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed SIGN",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x09}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSIGNW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed SIGN",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x0A}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSIGND",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed SIGN",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x0A}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PSIGND",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed SIGN",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x0B}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULHRSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Multiply High with Round and Scale",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x0B}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULHRSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Multiply High with Round and Scale",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x10}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PBLENDVB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "XMM0", .op4 = "",
        .iext = "sse41", .notes = "Variable Blend Packed Bytes",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x14}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "BLENDVPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "XMM0", .op4 = "",
        .iext = "sse41", .notes = "Variable Blend Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x15}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "BLENDVPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "XMM0", .op4 = "",
        .iext = "sse41", .notes = "Variable Blend Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x17}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PTEST",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Logical Compare",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x1C}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PABSB",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Absolute Value",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x1C}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PABSB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Absolute Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x1D}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PABSW",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Absolute Value",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x1D}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PABSW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Absolute Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0x1E}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PABSD",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Absolute Value",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x1E}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PABSD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Absolute Value",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x20}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVSXBW",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Sign Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x21}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVSXBD",
        .op1 = "xmm", .op2 = "m32", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Sign Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x22}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVSXBQ",
        .op1 = "xmm", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Sign Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x23}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVSXWD",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Sign Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x24}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVSXWQ",
        .op1 = "xmm", .op2 = "m32", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Sign Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x25}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVSXDQ",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Sign Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x28}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULDQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Multiply Packed Signed Dword Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x29}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPEQQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Compare Packed Qword Data for Equal",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x2A}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVNTDQA",
        .op1 = "xmm", .op2 = "m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Load Double Quadword Non-Temporal Aligned Hint",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x2B}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PACKUSDW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Pack with Unsigned Saturation",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x30}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVZXBW",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Zero Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x31}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVZXBD",
        .op1 = "xmm", .op2 = "m32", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Zero Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x32}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVZXBQ",
        .op1 = "xmm", .op2 = "m16", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Zero Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x33}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVZXWD",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Zero Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x34}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVZXWQ",
        .op1 = "xmm", .op2 = "m32", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Zero Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x35}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMOVZXDQ",
        .op1 = "xmm", .op2 = "m64", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Move with Zero Extend",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x37}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPGTQ",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse42", .notes = "Compare Packed Qword Data for Greater Than",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x38}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINSB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Minimum of Packed Signed Byte Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x39}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINSD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Minimum of Packed Signed Dword Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x3A}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINUW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Minimum of Packed Unsigned Word Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x3B}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMINUD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Minimum of Packed Unsigned Dword Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x3C}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXSB",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Maximum of Packed Signed Byte Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x3D}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXSD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Maximum of Packed Signed Dword Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x3E}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXUW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Maximum of Packed Unsigned Word Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x3F}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMAXUD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Maximum of Packed Unsigned Dword Integers",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x40}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PMULLD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Multiply Packed Signed Dword Integers and Store Low Result",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x41}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PHMINPOSUW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Packed Horizontal Word Minimum",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x80}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INVEPT",
        .op1 = "r32", .op2 = "m128", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Invalidate Translations Derived from EPT",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x38, 0x81}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INVVPID",
        .op1 = "r32", .op2 = "m128", .op3 = "", .op4 = "",
        .iext = "vmx", .notes = "Invalidate Translations Based on VPID",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0xF0}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVBE",
        .op1 = "r16/32", .op2 = "m16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move Data After Swapping Bytes",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 3, .op = {0x0F, 0x38, 0xF0}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CRC32",
        .op1 = "r32", .op2 = "r/m8", .op3 = "", .op4 = "",
        .iext = "sse42", .notes = "Accumulate CRC32 Value",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x38, 0xF1}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MOVBE",
        .op1 = "m16/32", .op2 = "r16/32", .op3 = "", .op4 = "",
        .iext = "", .notes = "Move Data After Swapping Bytes",
    },
    {
        .enc = { .pf = 0xF2, .op_len = 3, .op = {0x0F, 0x38, 0xF1}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "CRC32",
        .op1 = "r32", .op2 = "r/m16/32", .op3 = "", .op4 = "",
        .iext = "sse42", .notes = "Accumulate CRC32 Value",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x08}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ROUNDPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Round Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x09}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ROUNDPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Round Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x0A}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ROUNDSS",
        .op1 = "xmm", .op2 = "xmm/m32", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Round Scalar Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x0B}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "ROUNDSD",
        .op1 = "xmm", .op2 = "xmm/m64", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Round Scalar Double-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x0C}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "BLENDPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Blend Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x0D}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "BLENDPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Blend Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x0E}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PBLENDW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Blend Packed Words",
    },
    {
        .enc = { .pf = 0x00, .op_len = 3, .op = {0x0F, 0x3A, 0x0F}, .modrm_ext = -2 },
        .recipe = UOP_REC_MISC, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PALIGNR",
        .op1 = "mm", .op2 = "mm/m64", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Align Right",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x0F}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PALIGNR",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "ssse3", .notes = "Packed Align Right",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x14}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PEXTRB",
        .op1 = "m8", .op2 = "xmm", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Extract Byte",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x15}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PEXTRW",
        .op1 = "m16", .op2 = "xmm", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Extract Word",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x16}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PEXTRD",
        .op1 = "r/m32", .op2 = "xmm", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Extract Dword/Qword",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x17}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "EXTRACTPS",
        .op1 = "r/m32", .op2 = "xmm", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Extract Packed Single-FP Value",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x20}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PINSRB",
        .op1 = "xmm", .op2 = "m8", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Insert Byte",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x21}, .modrm_ext = -2 },
        .recipe = UOP_REC_STRING, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "INSERTPS",
        .op1 = "xmm", .op2 = "m32", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Insert Packed Single-FP Value",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x22}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PINSRD",
        .op1 = "xmm", .op2 = "r/m32", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Insert Dword/Qword",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x40}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DPPS",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Dot Product of Packed Single-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x41}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "DPPD",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "", .op4 = "",
        .iext = "sse41", .notes = "Dot Product of Packed Double-FP Values",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x42}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "MPSADBW",
        .op1 = "xmm", .op2 = "xmm/m128", .op3 = "imm8", .op4 = "",
        .iext = "sse41", .notes = "Compute Multiple Packed Sums of Absolute Difference",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x60}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPESTRM",
        .op1 = "XMM0", .op2 = "xmm", .op3 = "xmm/m128", .op4 = "...",
        .iext = "sse42", .notes = "Packed Compare Explicit Length Strings, Return Mask",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x61}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPESTRI",
        .op1 = "ECX", .op2 = "xmm", .op3 = "xmm/m128", .op4 = "...",
        .iext = "sse42", .notes = "Packed Compare Explicit Length Strings, Return Index",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x62}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPISTRM",
        .op1 = "XMM0", .op2 = "xmm", .op3 = "xmm/m128", .op4 = "imm8",
        .iext = "sse42", .notes = "Packed Compare Implicit Length Strings, Return Mask",
    },
    {
        .enc = { .pf = 0x66, .op_len = 3, .op = {0x0F, 0x3A, 0x63}, .modrm_ext = -2 },
        .recipe = UOP_REC_SIMD, .alu_op = UOP_ALU_NONE, .cc = UOP_CC_NONE,
        .mnemonic = "PCMPISTRI",
        .op1 = "ECX", .op2 = "xmm", .op3 = "xmm/m128", .op4 = "imm8",
        .iext = "sse42", .notes = "Packed Compare Implicit Length Strings, Return Index",
    },
};

size_t x86_uop_entry_count(void) { return sizeof(g_entries)/sizeof(g_entries[0]); }
const x86_uop_entry_t* x86_uop_entry_at(size_t i) {
    if (i >= x86_uop_entry_count()) return NULL;
    return &g_entries[i];
}

const x86_uop_entry_t* x86_uop_lookup(const x86_uop_encoding_t *k_in) {
    if (!k_in) return NULL;
    x86_uop_encoding_t k = *k_in;

    /* -------- grouped patterns first -------- */
    /* WARNING: returns pointer to static storage (not thread-safe). */
    static x86_uop_entry_t synth;

    /* Jcc short: 70..7F */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0x70 && k.op[0] <= 0x7F)) {
        const uint8_t n = (uint8_t)(k.op[0] & 0x0F);
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_JCC; synth.alu_op = UOP_ALU_NONE; synth.cc = g_cc_by_nibble[n];
        synth.mnemonic = "Jcc"; synth.op1 = "rel8"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized short Jcc";
        return &synth;
    }

    /* Jcc near: 0F 80..8F */
    if (1 && k.op_len == 2 && k.modrm_ext == -1 && k.op[0] == 0x0F && (k.op[1] >= 0x80 && k.op[1] <= 0x8F)) {
        const uint8_t n = (uint8_t)(k.op[1] & 0x0F);
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_JCC; synth.alu_op = UOP_ALU_NONE; synth.cc = g_cc_by_nibble[n];
        synth.mnemonic = "Jcc"; synth.op1 = "rel16/32"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized near Jcc";
        return &synth;
    }

    /* SETcc: 0F 90..9F /r */
    if (0 && k.op_len == 2 && k.modrm_ext == -2 && k.op[0] == 0x0F && (k.op[1] >= 0x90 && k.op[1] <= 0x9F)) {
        const uint8_t n = (uint8_t)(k.op[1] & 0x0F);
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_SETCC; synth.alu_op = UOP_ALU_NONE; synth.cc = g_cc_by_nibble[n];
        synth.mnemonic = "SETcc"; synth.op1 = "r/m8"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized SETcc";
        return &synth;
    }

    /* CMOVcc: 0F 40..4F /r */
    if (1 && k.op_len == 2 && k.modrm_ext == -2 && k.op[0] == 0x0F && (k.op[1] >= 0x40 && k.op[1] <= 0x4F)) {
        const uint8_t n = (uint8_t)(k.op[1] & 0x0F);
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_CMOVCC; synth.alu_op = UOP_ALU_NONE; synth.cc = g_cc_by_nibble[n];
        synth.mnemonic = "CMOVcc"; synth.op1 = "r16/32"; synth.op2 = "r/m16/32"; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized CMOVcc";
        return &synth;
    }

    /* MOV r8, imm8 : B0..B7 */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0xB0 && k.op[0] <= 0xB7)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_MOV; synth.alu_op = UOP_ALU_MOV; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "MOV"; synth.op1 = "r8"; synth.op2 = "imm8"; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized MOV r8, imm8";
        return &synth;
    }

    /* MOV r16/32, imm : B8..BF */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0xB8 && k.op[0] <= 0xBF)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_MOV; synth.alu_op = UOP_ALU_MOV; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "MOV"; synth.op1 = "r16/32"; synth.op2 = "imm16/32"; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized MOV r16/32, imm";
        return &synth;
    }

    /* PUSH reg : 50..57 */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0x50 && k.op[0] <= 0x57)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_STACK; synth.alu_op = UOP_ALU_NONE; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "PUSH"; synth.op1 = "r16/32"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized PUSH reg";
        return &synth;
    }

    /* POP reg : 58..5F */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0x58 && k.op[0] <= 0x5F)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_STACK; synth.alu_op = UOP_ALU_NONE; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "POP"; synth.op1 = "r16/32"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized POP reg";
        return &synth;
    }

    /* INC reg : 40..47 */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0x40 && k.op[0] <= 0x47)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_ALU; synth.alu_op = UOP_ALU_INC; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "INC"; synth.op1 = "r16/32"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized INC reg";
        return &synth;
    }

    /* DEC reg : 48..4F */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0x48 && k.op[0] <= 0x4F)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_ALU; synth.alu_op = UOP_ALU_DEC; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "DEC"; synth.op1 = "r16/32"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized DEC reg";
        return &synth;
    }

    /* XCHG eax, reg : 91..97 */
    if (1 && k.op_len == 1 && k.modrm_ext == -1 && (k.op[0] >= 0x91 && k.op[0] <= 0x97)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_MOV; synth.alu_op = UOP_ALU_XCHG; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "XCHG"; synth.op1 = "r16/32"; synth.op2 = "AX/EAX"; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized XCHG eax, reg";
        return &synth;
    }

    /* BSWAP reg : 0F C8..CF */
    if (1 && k.op_len == 2 && k.modrm_ext == -1 && k.op[0] == 0x0F && (k.op[1] >= 0xC8 && k.op[1] <= 0xCF)) {
        synth.enc = k; synth.enc.pf = 0;
        synth.recipe = UOP_REC_BSWAP; synth.alu_op = UOP_ALU_BSWAP; synth.cc = UOP_CC_NONE;
        synth.mnemonic = "BSWAP"; synth.op1 = "r16/32"; synth.op2 = ""; synth.op3 = ""; synth.op4 = "";
        synth.iext = ""; synth.notes = "Synthesized BSWAP reg";
        return &synth;
    }

    /* -------- exact match -------- */
    const size_t n = x86_uop_entry_count();
    for (size_t i=0;i<n;i++) {
        if (enc_eq(&g_entries[i].enc, &k)) return &g_entries[i];
    }

    /* -------- prefix fallback (66/F2/F3 -> 0 when no pf!=0 variants exist) -------- */
    if (k_in->pf == 0x66 || k_in->pf == 0xF2 || k_in->pf == 0xF3) {
        x86_uop_encoding_t k0 = k; k0.pf = 0;
        int have_mandatory_pf = 0;
        const x86_uop_entry_t *pf0 = NULL;
        for (size_t i=0;i<n;i++) {
            const x86_uop_entry_t *e = &g_entries[i];
            if (!enc_eq_ignore_pf(&e->enc, &k0)) continue;
            if (e->enc.pf != 0) have_mandatory_pf = 1;
            if (e->enc.pf == 0 && !pf0) pf0 = e;
        }
        if (!have_mandatory_pf && pf0) return pf0;
    }

    return NULL;
}
